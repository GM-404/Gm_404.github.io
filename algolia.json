[
  {
    "objectID": "fdf1826f31e0b72a6c516e3b40c340786948eb6e",
    "permalink": "/post/markdown%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/",
    "title": "markdown常见基础命令","content": "\r一些插件\rMarkdown All in One 提供自动补全 Markdown Preview Enhanced 优化渲染效果 Markdown Image 改善本地图片的插入效果\n1.标题:让你的内容层次分明\r一级标题\r二级标题\r三级标题\r2.段落与换行\r\u0026mdash;为分割线效果 功能二为换行符 现在是2025年4月11号晚上10点，我在学习 继续努力\n3.字体样式：强调你的文字\r斜体 粗体 粗斜体 删除线\n4.列表\r无序列表\n可以使用横杠，加号或者星号加空格来开始一行 吃饭 睡觉 打豆豆 有序列表\n有序列表使用数字加.号来开始一行 5.链接与图片\r百度 本项目github地址\n网图不显示 那就来一张自拍\n6.代码块\r单行代码print(\u0026quot;Hello World\u0026quot;) #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34; \u0026lt;\u0026lt; endl; return 0; } print(\u0026#34;Hello World\u0026#34;) 7.引用\r引用，这是第一次引用\n引用，这是第二次引用，也就是嵌套引用，虽然我认为没卵用\n8.分割线\r使用横杠，星号，或者下划线来创建分隔符\n9.表格\r表头1:左对齐 表头2：右对齐 表头三：居中对齐 内容1 内容2 我 内容3 内容4 你 数学公式\r一行数学公式 $E=mc^2$ 多行数学公式 $$E=mc^2 $$ 不好意思只会这个,那怎么可能$$\rd_{t} = \\sqrt{x^2 + y^2}\\\\\rd_{i,j} \\leftarrow d_{i,j} + 1\\\\\r$$ 流程图：可视化流程\rgraph TD\rA--\u003eB\rA--\u003eC\rB--\u003eD\rC--\u003eD\rpie\rtitle 项目完成情况\r\"已完成\" : 1\r\"未完成\" : 99\r","date": "2025-10-15 00:00",
    "updated": "2025-10-15 00:00"
  }, 
  {
    "objectID": "fd60437c7d3e6b82f589811f1af3d6fec07b1382",
    "permalink": "/post/%E4%BA%8C%E5%8F%89%E6%A0%91/",
    "title": "二叉树","content": "\r基础知识\r参考视频 https://www.bilibili.com/video/BV1UD4y1Y769/?spm_id_from=333.1007.top_right_bar_window_history.content.click\u0026amp;vd_source=de9d0b5f46420ead2e7be875b9558767\n递归的核心思想:不是人肉压栈，而是“shuai锅”\r你只需要关注两件事： 1.终止条件（Base Case）：什么时候问题小到可以直接解决，不需要再“甩锅”给下一层了？ 2.递归关系（Recursive Relation）：如何把当前问题，分解成一个或多个规模更小的同类子问题，并假设（信任）下一层调用能完美解决这些子问题。然后，你只需要思考如何利用子问题的解来组合成当前问题的解。 你不需要去想下一层是怎么实现的，你只要相信它能给你正确的结果就行了。 就像调用一个库函数sort()，你不会去关心它内部是快排还是归并.\n把递归函数本身，也当成一个黑盒的、可信赖的库函数来调用\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; // 定义二叉树节点 struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; /* 我们来定义函数 maxDepth(root) 它的功能是：接收一个树的根节点，返回这棵树的最大深度。 */ int maxDepth(TreeNode* root) { // 1. 终止条件 (Base Case) // 如果这个节点是空的（比如一个叶子节点的子节点）， // 那么它构成的树深度就是 0。这是最简单、可以直接回答的问题。 if (root == nullptr) { return 0; } // 2. 递归关系 (Recursive Relation) // 对于任何一个非空的节点 root，它的最大深度是多少？ // 我们可以把它分解成两个子问题： // - 左子树的最大深度是多少？ // - 右子树的最大深度是多少？ // 这两个子问题的规模都比当前问题（整棵树的深度）要小。 // 而且它们是同类问题：都是“计算一棵树的最大深度”。 // 所以，我们可以“甩锅”了！ // 我假设 maxDepth() 这个函数已经能完美工作了（信念之跃）。 // 我把它当成一个已知的、可靠的工具来调用。 // 我“相信”下面这行代码能正确计算出左子树的深度。 // 我不去想 aleftDepth 是怎么一步步算出来的。 int leftDepth = maxDepth(root-\u0026gt;left); // 我同样“相信”这行代码能正确计算出右子树的深度。 int rightDepth = maxDepth(root-\u0026gt;right); // 3. 组合子问题的解 // 现在，我已经拿到了两个子问题的答案：leftDepth 和 rightDepth。 // 如何用这两个答案来解决我当前的问题（以 root 为根的树的深度）？ // 很显然，整棵树的深度 = 左右子树深度的较大者 + 1 (当前这一层) return std::max(leftDepth, rightDepth) + 1; } int main() { /* 构造一棵树: 3 / \\ 9 20 / \\ 15 7 */ TreeNode* root = new TreeNode(3); root-\u0026gt;left = new TreeNode(9); root-\u0026gt;right = new TreeNode(20); root-\u0026gt;right-\u0026gt;left = new TreeNode(15); root-\u0026gt;right-\u0026gt;right = new TreeNode(7); std::cout \u0026lt;\u0026lt; \u0026#34;这棵树的最大深度是: \u0026#34; \u0026lt;\u0026lt; maxDepth(root) \u0026lt;\u0026lt; std::endl; // 应该输出 3 delete root-\u0026gt;left; delete root-\u0026gt;right-\u0026gt;left; delete root-\u0026gt;right-\u0026gt;right; delete root-\u0026gt;right; delete root; return 0; } 如何正确思考 maxDepth(root) 的过程？\r1.我的目标：实现 maxDepth(root) 函数。\n2.第一步：找终止条件。 什么情况下最简单？树是空的！if (root == nullptr)，深度就是 0。搞定。\n3.第二步：找递归关系。 如果树不空，root 指向一个节点。这棵树的深度和它的左右孩子有什么关系？\n左子树的深度。\n右子树的深度。\n整棵树的深度就是 max(左深度, 右深度) + 1。\n4.第三步：写代码（信念之跃）。 如何获取左子树的深度？直接调用maxDepth(root-\u0026gt;left)。相信它！ 不要去想它内部是怎么对 root-\u0026gt;left 的子节点进行递归的。就把它当成 int leftDepth = getLeftDepth() 这么一个普通的函数调用。\n如何获取右子树的深度？同理，调用 maxDepth(root-\u0026gt;right)。相信它！\n拿到 leftDepth 和 rightDepth 后，根据第二步的分析，return std::max(leftDepth, rightDepth) + 1;。\n整个思考过程，我们只关注“当前层”的逻辑。 我们把对子树的处理完全委托给了递归调用，我们是“管理者”，不是“微观执行者”。\n二叉树的递归遍历\r// 基本的二叉树节点 class TreeNode { public: int val; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} }; // 二叉树的递归遍历框架 void traverse(TreeNode* root) { if (root == nullptr) { return; } traverse(root-\u0026gt;left); traverse(root-\u0026gt;right); } 前序遍历（Pre-order Traversal）\rvoid preOrderTraversal(TreeNode* root) { // 1. 终止条件 if (root == nullptr) { return; // 空树就直接返回，什么也不做 } // 2. 处理当前节点 (根) std::cout \u0026lt;\u0026lt; root-\u0026gt;val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 访问根节点 // 3. 递归处理左子树 (左) // “信念之跃”：我相信这个调用会完美地以前序遍历的方式打印完整个左子树 preOrderTraversal(root-\u0026gt;left); // 4. 递归处理右子树 (右) // “信念之跃”：我相信这个调用会完美地以前序遍历的方式打印完整个右子树 preOrderTraversal(root-\u0026gt;right); } 正确思考 preOrderTraversal：\n1.我的目标：按“根-左-右”的顺序打印树。\n2.终止条件：root 是 nullptr，没什么可打印的，直接 return。\n3.当前层的逻辑：如果 root 不是 nullptr，根据“根-左-右”的定义，我应该：\n先处理“根”：cout \u0026laquo; root-\u0026gt;val;\n然后处理“左”：怎么处理？这是一个规模更小的同类问题，直接调用 preOrderTraversal(root-\u0026gt;left); 来搞定整个左子树。相信它能行！\n最后处理“右”：同理，调用 preOrderTraversal(root-\u0026gt;right); 来搞定整个右子树。相信它也能行！\n代码和逻辑完全一一对应，清晰明了。 你根本不需要去想，调用 preOrderTraversal(root-\u0026gt;left)之后，它又会怎么打印，怎么调用它的左孩子和右孩子。你只要相信这个函数的功能定义是正确的，你调用它，它就能完成任务。\n总结与建议\r明确函数定义：在写递归函数之前，用一句话清晰地描述这个函数的功能。例如：“maxDepth(node)的功能是返回以 node 为根的子树的最大深度”。在后续的递归调用中，始终坚信你调用的就是这个已经实现的功能。\n只考虑当前层：你的所有逻辑都应该只围绕“当前节点”展开。你需要做什么？你需要从子问题的解中得到什么信息？你如何利用这些信息？\n找到终止条件：思考什么情况下问题规模最小，可以被直接解决，不再需要递归。这是递归的出口，没有它就会无限循环，导致“栈溢出”。\n信任递归调用：这是最关键的一步。当你对 function(sub_problem) 进行调用时，就把它当成一个已知的、正确的黑盒。你的任务不是去追踪它的执行，而是去使用它的返回结果。\n当你下次再遇到一个递归问题时，请抑制住你的大脑去模拟整个调用栈的冲动。强迫自己用上面的思维模式去思考，多练习几次，你会发现递归问题会变得异常清晰和简单。它是一种将复杂问题分解为简单、重复单元的强大思维工具。\n1. 基础遍历类 (Basic Traversal)\r这类问题的核心是“访问”到每一个节点并执行简单操作，递归函数本身通常没有返回值（void）或者返回一个包含所有节点值的列表。\n核心思路： 定义一个 traverse(node) 函数，在函数内部先处理当前节点，然后递归调用 traverse(node-\u0026gt;left) 和 traverse(node-\u0026gt;right)。根据处理当前节点的时机不同，分为前、中、后序遍历。\n经典题目:\r144. 二叉树的前序遍历\rclass Solution { public: void perorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res) { if (root == nullptr) return; res.push_back(root-\u0026gt;val); perorder(root-\u0026gt;left, res); perorder(root-\u0026gt;right, res); } vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; perorder(root, res); return res; } }; 94. 二叉树的中序遍历\rclass Solution { public: void inorder(TreeNode *node, vector\u0026lt;int\u0026gt; \u0026amp;res) { if (node == nullptr) return; inorder(node-\u0026gt;left, res); res.push_back(node-\u0026gt;val); inorder(node-\u0026gt;right, res); } vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode *root) { vector\u0026lt;int\u0026gt; res; inorder(root, res); return res; } }; 145. 二叉树的后序遍历\rclass Solution { public: void postorder(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res) { if (root == nullptr) return; postorder(root-\u0026gt;left, res); postorder(root-\u0026gt;right, res); res.push_back(root-\u0026gt;val); } vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; res; postorder(root, res); return res; } }; 2. 分治 / 自下而上信息汇总 (Divide and Conquer / Bottom-up)\r这是最最常见的一类递归问题。你相信递归函数能帮你解决子问题，然后你只需要思考如何利用子问题的解来解决当前问题。\n核心思路 ： “我不知道怎么解决整棵树的问题，但我假设 solve(root-\u0026gt;left) 和 solve(root-\u0026gt;right) 已经帮我解决了左右子树的问题并返回了正确的结果。现在，我只需要在当前 root 节点，利用这两个结果，计算出当前树的结果，然后 return 回去。”\n经典题目:\r104. 二叉树的最大深度 (我们之前讨论过的)\r左子树深度 = solve(root-\u0026gt;left), 右子树深度 = solve(root-\u0026gt;right)\n当前树深度 = max(左子树深度, 右子树深度) + 1\n111. 二叉树的最小深度 (最大深度的变体，注意处理只有单边子树的情况)\rint minDepth(TreeNode* root) { if (root == nullptr) return 0; int ldepth = minDepth(root-\u0026gt;left); int rdepth = minDepth(root-\u0026gt;right); if (root-\u0026gt;right == nullptr) { return ldepth+1; } if (root-\u0026gt;left == nullptr) { return rdepth+1; } return min(ldepth, rdepth) + 1; } 543.二叉树的直径543.二叉树的直径\rint landrDepth(TreeNode* root,int\u0026amp; maxdepth) { if (root == nullptr) return 0; int ldepth = landrDepth(root-\u0026gt;left,maxdepth); int rdepth = landrDepth(root-\u0026gt;right,maxdepth); int currentdepth = ldepth + rdepth; maxdepth = max(maxdepth,currentdepth); return max(ldepth,rdepth)+1; } int diameterOfBinaryTree(TreeNode* root) { int maxdepth=0; landrDepth(root,maxdepth); return maxdepth; } ","date": "2025-10-15 00:00",
    "updated": "2025-10-15 00:00"
  }, 
  {
    "objectID": "564df43d3b6fa16ddee98662daeb80802dfb29d2",
    "permalink": "/post/%E7%82%92%E8%82%A1%E6%97%A5%E8%AE%B0/",
    "title": "炒股日记","content": "\r目前持有\r前海联合泳隆混合A\r银华上证科创板人工智能ETF联接C\r国泰国证有色金属行业指数C\r兴业安保优选混合C\r中欧信息科技混合C\r银华中证光伏产业ETF联接C\r大摩万众创新灵活配置混合A\r广发汽车指数C\r中欧医疗创新股票C\r华泰柏瑞港股通医疗精选混合C\r银华海外数字经济量化选股混合C\r国泰国证有色金属行业指数A\r银华中证创新药产业ETF联接C\r国泰国证食品饮料行业指数C\r华泰柏瑞中证红利低波动ETF联接C\r创金合信医疗保健行业股票C\r","date": "2025-10-01 21:46",
    "updated": "2025-10-01 21:46"
  }, 
  {
    "objectID": "7d3af3ae93e795ea3de4ac1634ce0ad8a250d970",
    "permalink": "/post/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/",
    "title": "搭建博客教程","content": "By GM-404\n一、准备工作\r安装 Hugo\nWindows： 访问 Hugo Releases 下载最新的 hugo_extended_xxx_Windows-64bit.zip 解压后将 hugo.exe 所在文件夹添加到系统环境变量 PATH 中 macOS：brew install hugo Linux：sudo apt install hugo 或通过源码编译 验证安装：终端输入 hugo version，显示版本号则成功 安装 Git\n用于版本控制和部署，下载地址：Git 官网 验证：git --version 二、创建 Hugo 博客项目\r初始化博客\n# 创建博客目录（blog-name 替换为你的博客名） hugo new site blog-name cd blog-name 初始化 Git 仓库\nbash\ngit init # 创建 .gitignore 文件（忽略临时文件） echo \u0026#34;public/\u0026#34; \u0026gt;\u0026gt; .gitignore echo \u0026#34;resources/\u0026#34; \u0026gt;\u0026gt; .gitignore 三、选择并安装主题\r挑选主题\n推荐网站：Hugo 主题库 新手友好主题： LoveIt（功能全、美观） PaperMod（简洁、响应式） Even（极简风格） 安装主题（以 LoveIt 为例）\nbash\n# 作为 Git 子模块安装（方便更新） git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 启用主题\n编辑博客根目录的 config.toml 文件，添加：\ntoml\ntheme = \u0026#34;LoveIt\u0026#34; 四、配置博客基础信息\r修改配置文件 编辑 config.toml，替换默认内容（以 LoveIt 主题为例）： baseURL = \u0026#34;https://你的域名/\u0026#34; # 后续部署的域名 languageCode = \u0026#34;zh-CN\u0026#34; # 语言（中文） title = \u0026#34;我的博客\u0026#34; # 博客标题 theme = \u0026#34;LoveIt\u0026#34; # 可选：启用评论、社交链接等 [params] author = \u0026#34;你的名字\u0026#34; description = \u0026#34;这是我的个人博客\u0026#34; [params.social] github = \u0026#34;你的 GitHub 用户名\u0026#34; twitter = \u0026#34;你的 Twitter 用户名\u0026#34; 主题不同，配置项可能有差异，建议参考主题文档调整。 五、创建第一篇文章\r生成文章 # 创建一篇新文章（路径：content/posts/我的第一篇文章.md） hugo new posts/我的第一篇文章.md 编辑文章内容 打开生成的 Markdown 文件，默认内容如下： --- title: \u0026#34;我的第一篇文章\u0026#34; date: 2024-09-13T10:00:00+08:00 draft: true # 草稿状态（true 表示不发布） --- 这里是文章内容... 修改 draft: false 表示发布，然后添加正文（支持 Markdown 语法）。 六、本地预览博客\r启动本地服务器\nhugo server -D # -D 表示包含草稿文章 访问预览\n打开浏览器访问 http://localhost:1313，即可看到博客效果 修改内容后会自动刷新，实时预览 七、生成静态文件\r完成编辑后，生成可部署的静态文件：\nhugo # 生成文件到 public 目录 八、部署博客（以 GitHub Pages 为例）\r创建 GitHub 仓库\n新建仓库，命名为 用户名.github.io（必须是这个格式，例如 john.github.io） 关联仓库并部署\nbash\n# 进入生成的静态文件目录 cd public # 初始化仓库并关联远程 git init git remote add origin https://github.com/用户名/用户名.github.io.git # 提交并推送 git add . git commit -m \u0026#34;首次部署博客\u0026#34; git push -u origin main 访问博客\n等待几分钟，访问 https://用户名.github.io 即可看到你的博客 下一步操作建议：\r登录 GitHub，进入你的仓库 GM-404/GM-404.github.io 点击顶部的 Settings 选项卡 在左侧菜单找到 Pages 选项 在 Source 部分，选择分支为 master（如果未自动选中），目录保持 / (root) 点击 Save 保存设置 稍等几分钟（GitHub Pages 构建需要时间），你的博客就可以通过 https://gm-404.github.io 访问了(给自己打一波流量)。\n","date": "2025-09-29 20:12",
    "updated": "2025-09-29 20:12"
  }, 
  {
    "objectID": "a08df0704d76c3aa881313c88f1e3fe21b278182",
    "permalink": "/post/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/",
    "title": "力扣刷题","content": "\r基础知识\r链表代码实现\r#include \u0026lt;iostream\u0026gt; #include \u0026lt;stdexcept\u0026gt; class MyLinkedList { private: struct Node { int val; Node* next; Node* prev; Node(int value) : val(value), next(nullptr), prev(nullptr) {} }; Node* head; // 虚拟头节点 Node* tail; // 虚拟尾节点 int size; // 辅助函数：查找索引处的节点（用于插入和遍历） // 当 index = size 时，返回 tail 节点 Node* getNode(int index) const { // **优化：从头尾中较近的一端开始遍历** Node* p; if (index \u0026lt; size / 2) { // 从头开始：head-\u0026gt;next 是 index 0 对应的节点 p = head-\u0026gt;next; for (int i = 0; i \u0026lt; index; i++) { p = p-\u0026gt;next; } } else { // 从尾开始：tail-\u0026gt;prev 是 index size-1 对应的节点 p = tail; for (int i = 0; i \u0026lt; (size - index); i++) { p = p-\u0026gt;prev; } } return p; } // 检查 index 索引位置是否可以存在元素 [0, size-1] bool isElementIndex(int index) const { return index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt; size; } // 检查 index 索引位置是否可以添加元素 [0, size] bool isPositionIndex(int index) const { return index \u0026gt;= 0 \u0026amp;\u0026amp; index \u0026lt;= size; } public: MyLinkedList() { head = new Node(0); tail = new Node(0); head-\u0026gt;next = tail; tail-\u0026gt;prev = head; size = 0; } // 析构函数（补充：用于释放内存，解决内存泄漏） ~MyLinkedList() { Node* curr = head; while (curr != nullptr) { Node* next = curr-\u0026gt;next; delete curr; curr = next; } head = nullptr; tail = nullptr; size = 0; } // --- 增加 --- void addAtHead(int val) { // 利用 addAtIndex(0, val) 实现最简洁 addAtIndex(0, val); } void addAtTail(int val) { // 利用 addAtIndex(size, val) 实现最简洁 addAtIndex(size, val); } void addAtIndex(int index, int val) { // 核心修改：检查位置索引的有效性 if (!isPositionIndex(index)) { // 题目要求：如果 index 比长度更大，该节点将不会插入 // 这里我们直接返回，不抛出异常 return; } // 找到插入位置的节点 (node)，它将成为新节点 x 的 next // 当 index=size 时，node 刚好是 tail Node* node = getNode(index); Node* prev_node = node-\u0026gt;prev; Node* x = new Node(val); // 插入操作： prev_node \u0026lt;-\u0026gt; x \u0026lt;-\u0026gt; node x-\u0026gt;prev = prev_node; x-\u0026gt;next = node; node-\u0026gt;prev = x; prev_node-\u0026gt;next = x; // 更新数量 size++; } // --- 查 --- int get(int index) { // 核心修改：检查元素索引的有效性 if (!isElementIndex(index)) { return -1; // 题目要求：下标无效，返回 -1 } // 找到 index 对应的 Node Node* p = getNode(index); // 由于上面已经检查了索引，p 必然是有效的实际元素节点，不是 tail 或 nullptr return p-\u0026gt;val; } // --- 删 --- void deleteAtIndex(int index) { // 核心修改：检查元素索引的有效性 if (!isElementIndex(index)) { return; // 题目要求：如果下标无效，不执行删除 } // 找到 index 对应的 Node (x)，它必然是有效的实际元素节点 Node* x = getNode(index); Node* prev = x-\u0026gt;prev; Node* next = x-\u0026gt;next; // 绕过 x prev-\u0026gt;next = next; next-\u0026gt;prev = prev; // 对删去的节点清空内存 delete x; // 更新数量 size--; } }; 哈希表\r哈希表核心原理\r哈希表可以理解为一个加强版的数组。 数组可以通过索引在 O(1) 的时间复杂度内查找到对应元素，索引是一个非负整数。\n哈希表是类似的，可以通过 key 在O(1) 的时间复杂度内查找到这个 key 对应的 value。key 的类型可以是数字、字符串等多种类型。\n怎么做的？特别简单，哈希表的底层实现就是一个数组（我们不妨称之为 table）。它先把这个 key 通过一个哈希函数（我们不妨称之为 hash）转化成数组里面的索引，然后增删查改操作和数组基本相同\n简单理解就是把键当成数组里面的元素，对键操作就算是对值操作了 key 是唯一的，value 可以重复 哈希函数的作用是把任意长度的输入（key）转化成固定长度的输出（索引）。\n所以，增删查改的方法中都会用到哈希函数来计算索引，如果你设计的这个哈希函数复杂度是 O(N)，那么哈希表的增删查改性能就会退化成 O(N)，所以说这个函数的性能很关键。\n所以并不是提到哈希增删改查就是O(1)的复杂度，要看你设计的哈希函数是怎么样的\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; ","date": "2025-09-29 00:00",
    "updated": "2025-10-10 00:00"
  }, 
  {
    "objectID": "fe6de0cb18f91724e911450b47ef9546c684d122",
    "permalink": "/post/markdown%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0/",
    "title": "Markdown 基本使用方法","content": "\rMarkdown 基本元素\r标题\rH1\rH2\rH3\rH4\rH5\rH6\r强调\rEmphasis, aka italics, with asterisks or underscores.\nStrong emphasis, aka bold, with asterisks or underscores.\nCombined emphasis with asterisks and underscores.\nStrikethrough uses two tildes. Scratch this.\n列表\rDefinition List (dl)\rOrdered List (ol)\rList Item 1 List Item 2 List Item 3 Unordered List (ul)\rList Item 1 List Item 2 List Item 3 段落\rLorem ipsum dolor sit amet, test link consectetur adipiscing elit. Strong text pellentesque ligula commodo viverra vehicula. Italic text at ullamcorper enim. Morbi a euismod nibh. Underline text non elit nisl. Deleted text tristique, sem id condimentum tempus, metus lectus venenatis mauris, sit amet semper lorem felis a eros. Fusce egestas nibh at sagittis auctor. Sed ultricies ac arcu quis molestie. Donec dapibus nunc in nibh egestas, vitae volutpat sem iaculis. Curabitur sem tellus, elementum nec quam id, fermentum laoreet mi. Ut mollis ullamcorper turpis, vitae facilisis velit ultricies sit amet. Etiam …","date": "2022-06-09 20:12",
    "updated": "2022-06-09 20:12"
  }, 
  {
    "objectID": "5b2d67ec48c6c5df22c2f19c6bc7d175785738cd",
    "permalink": "/post/chinese/",
    "title": "中文測試","content": "This is a Chinese test post.\n善我王上魚、產生資西員合兒臉趣論。畫衣生這著爸毛親可時，安程幾？合學作。觀經而作建。都非子作這！法如言子你關！手師也。\n以也座論頭室業放。要車時地變此親不老高小是統習直麼調未，行年香一？\n就竟在，是我童示讓利分和異種百路關母信過明驗有個歷洋中前合著區亮風值新底車有正結，進快保的行戰從：弟除文辦條國備當來際年每小腳識世可的的外的廣下歌洲保輪市果底天影；全氣具些回童但倒影發狀在示，數上學大法很，如要我……月品大供這起服滿老？應學傳者國：山式排只不之然清同關；細車是！停屋常間又，資畫領生，相們制在？公別的人寫教資夠。資再我我！只臉夫藝量不路政吃息緊回力之；兒足灣電空時局我怎初安。意今一子區首者微陸現際安除發連由子由而走學體區園我車當會，經時取頭，嚴了新科同？很夫營動通打，出和導一樂，查旅他。坐是收外子發物北看蘭戰坐車身做可來。道就學務。\n國新故。\n工步他始能詩的，裝進分星海演意學值例道……於財型目古香亮自和這乎？化經溫詩。只賽嚴大一主價世哥受的沒有中年即病行金拉麼河。主小路了種就小為廣不？\nFrom 亂數假文產生器 - Chinese Lorem Ipsum\n","date": "2022-06-09 20:12",
    "updated": "2022-06-09 20:12"
  }]